import logging

from discord.ext import commands

from HuskyBot import HuskyBot
from libhusky.HuskyStatics import *
from libhusky.discordpy.converters import UserConverter
from libhusky.util import DateUtil
from .IntelligenceStatics import *

LOG = logging.getLogger("HuskyBot.Plugin." + __name__)


class Intelligence(commands.Cog):
    """
    Intelligence is a plugin focusing on gathering information from Discord.

    It is used to query data about users (or roles/guilds) from guilds. Commands are generally open to execution for
    all users, and only expose information provided by the Discord API, not information generated by the bot or bot
    commands.

    All commands here query their information directly from the Discord API in near realtime.
    """

    def __init__(self, bot: HuskyBot):
        self.bot = bot
        LOG.info("Loaded plugin!")

    @commands.command(name="guildinfo", aliases=["sinfo", "ginfo"], brief="Get information about the current guild")
    @commands.guild_only()
    async def guild_info(self, ctx: commands.Context):
        """
        This command returns basic core information about a guild for reporting purposes.
        """

        guild = ctx.guild

        guild_details = discord.Embed(
            title="Guild Information for " + guild.name,
            color=guild.owner.color or Colors.INFO
        )

        guild_details.set_thumbnail(url=guild.icon_url)
        guild_details.add_field(name="Guild ID", value=guild.id, inline=True)
        guild_details.add_field(name="Owner", value=f"{discord.utils.escape_markdown(guild.owner.display_name)}"
                                                    f"#{guild.owner.discriminator}",
                                inline=True)
        guild_details.add_field(name="Members", value=str(len(guild.members)) + " users", inline=True)
        guild_details.add_field(name="Text Channels", value=str(len(guild.text_channels)) + " channels", inline=True)
        guild_details.add_field(name="Roles", value=str(len(guild.roles)) + " roles", inline=True)
        guild_details.add_field(name="Voice Channels", value=str(len(guild.voice_channels)) + " channels", inline=True)
        guild_details.add_field(name="Created At", value=guild.created_at.strftime(DATETIME_FORMAT), inline=True)
        guild_details.add_field(name="Region", value=guild.region, inline=True)

        if len(guild.features) > 0:
            guild_details.add_field(name="Features", value=", ".join(guild.features))

        await ctx.send(embed=guild_details)

    @commands.command(name="roleinfo", aliases=["rinfo"], brief="Get information about a specified role.")
    @commands.guild_only()
    async def role_info(self, ctx: discord.ext.commands.Context, *, role: discord.Role):
        """
        This command will dump configuration information (with the exception of permissions) for the selected role. It
        will also attempt to count the number of users with the specified role.
        Parameters
        ----------
            ctx   :: Context <!nodoc>
            role  :: A uniquely identifying role string. This can be a role mention, a role ID, or name.
                     This parameter is case-sensitive, but does not need to be "quoted in case of spaces."
        Examples
        --------
            /roleinfo Admins  :: Get information about the role "Admins"
        """

        role_details = discord.Embed(
            title=f"Role Information for {discord.utils.escape_markdown(role.name)}",
            color=role.color
        )

        role_details.add_field(name="Role ID", value=role.id, inline=True)

        if role.color.value == 0:
            role_details.add_field(name="Color", value="None", inline=True)
        else:
            role_details.add_field(name="Color", value=str(hex(role.color.value)).replace("0x", "#"), inline=True)

        role_details.add_field(name="Mention Preview", value=role.mention, inline=True)
        role_details.add_field(name="Hoisted", value=role.hoist, inline=True)
        role_details.add_field(name="Managed Role", value=role.managed, inline=True)
        role_details.add_field(name="Mentionable", value=role.mentionable, inline=True)
        role_details.add_field(name="Position", value=role.position, inline=True)
        role_details.add_field(name="Member Count", value=str(len(role.members)), inline=True)

        await ctx.send(embed=role_details)

    @commands.command(name="userinfo", brief="Get information about a user", aliases=["whois", "uinfo"])
    async def user_info(self, ctx: commands.context, *, user: UserConverter.OfflineMemberConverter = None):
        # ToDo: make this better.
        await ctx.send(user)

    @commands.command(name="avatar", brief="Get a high-resolution version of a user's avatar")
    async def avatar(self, ctx: commands.Context, *, user: UserConverter.OfflineUserConverter = None):
        """
        This command will attempt to find and return the largest possible version of a user's avatar that it can, as
        well as the avatar hash.

        This command takes a single (optional) argument - a member identifier. This may be a User ID, a ping, a
        username, a nickname, etc. If this argument is not specified, the bot will return the avatar of the calling
        user.

        Parameters
        ----------
            ctx   :: Discord context <!nodoc>
            user  :: A uniquely identifying user string, such as a mention, a user ID, a username, or a nickname.
                    This parameter is case-sensitive, but does not need to be "quoted in case of spaces."

        Examples
        --------
            /avatar                :: Get the calling user's avatar.
            /avatar SomeUser#1234  :: Get avatar for user "SomeUser#1234"
        """

        # default to the calling user if one wasn't specified.
        user = user or ctx.author

        embed = discord.Embed(
            title=f"Avatar for {user}",
            color=Colors.INFO
        )

        embed.add_field(name="Avatar ID", value=f"`{user.avatar}`", inline=False)
        embed.add_field(name="Avatar URL", value=f"[Open In Browser >]({user.avatar_url})", inline=False)
        embed.set_image(url=user.avatar_url)

        await ctx.send(embed=embed)

    @commands.command(name="usercount", brief="Get a count of users on the guild", aliases=["uc"])
    async def user_count(self, ctx: commands.Context):
        """
        This command will return a count of all members on the guild. It's really that simple.

        See Also
        --------
            /help activeusercount  :: Get a count of active users on the guild.
        """

        breakdown = {}

        for u in ctx.guild.members:  # type: discord.Member
            breakdown[u.status] = breakdown.get(u.status, 0) + 1

        embed = discord.Embed(
            title=Emojis.WAVE + " User Count Report",
            description=f"{ctx.guild.name} currently has **{sum(breakdown.values())} total users**.\n\n"
                        f"**Online Users:** {breakdown.get(discord.Status.online, 0)}\n"
                        f"**Idle Users:** {breakdown.get(discord.Status.idle, 0)}\n"
                        f"**DND Users:** {breakdown.get(discord.Status.dnd, 0)}\n"
                        f"**Offline Users:** {breakdown.get(discord.Status.offline, 0)}",
            color=Colors.INFO
        )

        await ctx.send(embed=embed)

    @commands.command(name="invitespy", brief="Get information about a Discord invite", aliases=["invspy"])
    async def invite_spy(self, ctx: commands.Context, fragment: str):
        """
        This command allows moderators to pull information about any given (valid) invite. It will display all
        publicly-gleanable information about the invite such as user count, verification level, join channel names,
        the invite's creator, and other such information.

        This command calls the API directly, and will validate an invite's existence. If either the bot's account
        or the bot's IP are banned, the system will act as though the invite does not exist.

        Parameters
        ----------
            ctx       :: Discord context <!nodoc>
            fragment  :: Either a Invite URL or fragment (aa1122) for the invite you wish to target.

        Examples
        --------
            /invitespy aabbcc                              :: Get invite data for invite aabbcc
            /invitespy https://disco\u200brd.gg/someguild  :: Get invite data for invite someguild
        """

        clean_fragment = discord.utils.resolve_invite(fragment)

        try:
            invite_data: dict = await ctx.bot.http.get_invite(clean_fragment, with_counts=True)
            # noinspection PyProtectedMember
            invite: discord.Invite = discord.Invite.from_incomplete(state=ctx.bot._connection, data=invite_data.copy())
        except discord.NotFound:
            await ctx.send(embed=discord.Embed(
                title="Could Not Retrieve Invite Data",
                description="This invite does not appear to exist, or the bot has been banned from the guild.",
                color=Colors.DANGER
            ))
            return

        embed = discord.Embed(
            description=f"Information about invite slug `{clean_fragment}`",
            color=Colors.INFO
        )

        if invite.guild:
            invite_target_name = "Guild: " + discord.utils.escape_markdown(invite.guild.name)
            embed.set_thumbnail(url=invite.guild.icon_url)
            embed.add_field(name="Guild Name", value=discord.utils.escape_markdown(invite.guild.name), inline=False)

            embed.add_field(name="Guild ID", value=invite.guild.id, inline=True)
            embed.add_field(name="Guild Creation Date", value=invite.guild.created_at.strftime(DATETIME_FORMAT),
                            inline=True)
            embed.add_field(name="Verification Level", value=INVSPY_VL_MAP[invite.guild.verification_level],
                            inline=True)

            if invite.channel:
                ch_prefix = INVSPY_CHANNEL_PREFIX_MAP.get(invite.channel.type)
                embed.add_field(name="Target Channel", value=f"{ch_prefix}{invite.channel.name}", inline=True)
                embed.add_field(name="Target Channel ID", value=invite.channel.id, inline=True)

            if invite.guild.features:
                embed.add_field(name="Guild Features", value=', '.join(list(f'`{f}`' for f in invite.guild.features)),
                                inline=False)

            if invite.guild.description:
                embed.add_field(name="Guild Description", value=invite.guild.description, inline=False)

            if invite.guild.splash_url:
                embed.add_field(name="Splash Image",
                                value=f"[Open in Browser >]({invite.guild.splash_url})",
                                inline=True)

            if invite.guild.banner_url:
                embed.add_field(name="Banner Image",
                                value=f"[Open in Browser >]({invite.guild.banner_url})",
                                inline=True)

        else:
            if invite.channel.name:
                invite_target_name = f"Group DM: {invite.channel.name}"
                embed.add_field(name="Group DM Name", value=discord.utils.escape_markdown(invite.channel.name),
                                inline=True)
            else:
                invite_target_name = "Group DM"

            embed.add_field(name="Group DM ID", value=invite.channel.id, inline=True)

            icon_id = invite_data.get('channel', {}).get('icon')
            if icon_id:
                thumb_url = f"https://cdn.discordapp.com/channel-icons/{invite.channel.id}/{icon_id}.webp"
                embed.set_thumbnail(url=thumb_url)

            recipient_o: list = invite_data.get('channel', {}).get('recipients', [])
            if recipient_o:
                recipient_list = ', '.join(r.get('username') for r in recipient_o)
                embed.add_field(name="Group DM Members", value=recipient_list, inline=False)

        if invite.inviter:
            embed.set_author(
                name=f"Invite for {invite_target_name} by {discord.utils.escape_markdown(str(invite.inviter))}",
                icon_url=invite.inviter.avatar_url
            )
        else:
            embed.set_author(name=f"Invite for {invite_target_name}")

        if invite.approximate_member_count:
            membercount_str = f"{invite.approximate_member_count} members"

            if invite.approximate_presence_count:
                membercount_str += f" ({invite.approximate_presence_count} online)"

            embed.add_field(name="Member Count", value=membercount_str, inline=False)

        embed.set_footer(text=f"Report generated at {DateUtil.get_current_timestamp()}")

        await ctx.send(embed=embed)
